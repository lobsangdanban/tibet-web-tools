<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>汇编语言教程</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.7; /* 增加默认行距 */
        }
        #app {
            max-width: 960px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 700; /* 加粗标题 */
            line-height: 1.2; /* 调整标题行距 */
        }
        h1 {
            font-size: 2.2em; /* 增大h1字体 */
            text-align: center;
            margin-bottom: 30px;
        }
        h2 {
            font-size: 1.8em; /* 增大h2字体 */
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        h3 {
            font-size: 1.4em; /* 增大h3字体 */
            margin-top: 25px;
        }
        p {
            font-size: 1.1em; /* 增加段落字体 */
            margin-bottom: 20px;
        }
        ul, ol {
            margin-bottom: 20px;
            padding-left: 25px; /* 增加列表缩进 */
        }
        li {
            font-size: 1.1em; /* 增加列表项字体 */
            margin-bottom: 10px; /* 增加列表项间距 */
        }
        ul {
            list-style-type: disc;
        }
        ol {
            list-style-type: decimal;
        }
        pre {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.9em;
            line-height: 1.5;
            border-radius: 6px;
        }
        strong {
            color: #e74c3c; /* 强调文本颜色 */
            font-weight: bold;
        }
        code {
            font-family: monospace;
            font-size: 0.9em;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
            color: #2c3e50;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 1.1em; /* 增大表格字体 */
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px; /* 增加表格单元格内边距 */
            text-align: left;
        }
        th {
            background-color: #f0f0f0;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f8f8f8; /* 偶数行背景色 */
        }
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        a:hover {
            color: #217dbb;
        }
        .exercise {
            background-color: #f0f0f0;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #3498db; /* 练习题左侧边框 */
            border-radius: 6px;
        }
        .exercise h4 {
            color: #3498db;
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        .solution {
            background-color: #e0f7fa;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #2ecc71; /* 解答左侧边框 */
            border-radius: 6px;
        }
        .solution h4 {
            color: #2ecc71;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        /* 为Vue.js的导航添加样式 */
        .nav {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .nav-item {
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            text-decoration: none;
            transition: background-color 0.3s ease;
            font-size: 1.1em;
        }
        .nav-item:hover {
            background-color: #217dbb;
        }
        .nav-item.active {
            background-color: #2c3e50;
        }

        /* 添加章节标题样式 */
        .chapter-title {
            font-size: 2.5em;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 40px;
            font-weight: bold;
            letter-spacing: 2px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 15px;
        }

        /* 增加图片样式 */
        img {
            max-width: 100%; /* 确保图片不会超出容器宽度 */
            height: auto; /* 保持图片宽高比 */
            margin: 10px 0; /* 上下边距 */
            border-radius: 6px; /* 可选：添加圆角 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* 可选：添加阴影 */
        }
        .center-image {
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 50%; /* 调整图片宽度 */
        }

    </style>
</head>
<body>
    <div id="app">
        <h1 class="chapter-title">汇编语言教程</h1>
        <nav class="nav">
            <a href="#introduction" class="nav-item">1. 汇编语言简介</a>
            <a href="#environment" class="nav-item">2. 开发环境搭建</a>
            <a href="#basic-syntax" class="nav-item">3. 汇编语言基础语法</a>
            <a href="#memory-registers" class="nav-item">4. 内存与寄存器</a>
            <a href="#addressing-modes" class="nav-item">5. 寻址方式</a>
            <a href="#instructions" class="nav-item">6. 汇编指令</a>
            <a href="#procedures" class="nav-item">7. 过程（函数）</a>
            <a href="#stack" class="nav-item">8. 栈</a>
            <a href="#input-output" class="nav-item">9. 输入输出</a>
            <a href="#interrupts" class="nav-item">10. 中断</a>
            <a href="#advanced-topics" class="nav-item">11. 高级主题</a>
            <a href="#exercises" class="nav-item">12. 综合练习</a>
            <a href="#resources" class="nav-item">13. 学习资源</a>
        </nav>

        <h2 id="introduction">1. 汇编语言简介</h2>
        <p>
            汇编语言是一种<strong>低级语言</strong>，它使用助记符来表示机器指令。每条汇编指令通常对应一个机器指令，因此汇编语言与特定的计算机体系结构紧密相关。
        </p>
        <p>
            与高级语言（如C、Java）相比，汇编语言具有以下特点：
        </p>
        <ul>
            <li><strong>直接控制硬件：</strong> 能够直接访问和控制计算机的硬件资源，如寄存器、内存和I/O端口。</li>
            <li><strong>效率高：</strong> 编写的代码执行效率通常比高级语言更高，因为减少了编译器的抽象层次。</li>
            <li><strong>代码量大：</strong> 完成相同功能的代码量通常比高级语言更多，开发效率较低。</li>
            <li><strong>可读性差：</strong> 相比高级语言，汇编代码的可读性较差，难以理解和维护。</li>
            <li><strong>依赖于体系结构：</strong> 汇编代码依赖于特定的计算机体系结构（如x86、ARM），可移植性差。</li>
        </ul>
        <p>
            尽管汇编语言在现代软件开发中应用较少，但它仍然在以下领域发挥着重要作用：
        </p>
        <ul>
            <li><strong>操作系统开发：</strong> 操作系统的底层功能，如进程管理、内存管理和设备驱动程序，通常使用汇编语言编写。</li>
            <li><strong>嵌入式系统：</strong> 资源受限的嵌入式系统，如微控制器，常常使用汇编语言进行编程，以实现最高的效率和最小的体积。</li>
            <li><strong>逆向工程：</strong> 分析和理解程序的底层行为，例如破解软件或分析病毒。</li>
            <li><strong>性能优化：</strong> 对程序的关键部分进行优化，以提高执行速度。</li>
        </ul>
        <p>
            本教程将以<strong>Intel x86</strong> 汇编语言为例，介绍汇编语言的基础知识和编程技巧。
        </p>

        <h2 id="environment">2. 开发环境搭建</h2>
        <p>
            学习汇编语言需要一个合适的开发环境。本节介绍如何在Windows和Linux系统上搭建x86汇编语言的开发环境。
        </p>
        <h3>2.1 Windows</h3>
        <p>
            在Windows上，我们通常使用以下工具：
        </p>
        <ul>
            <li><strong>MASM (Microsoft Macro Assembler)：</strong> 微软官方的汇编器，用于将汇编代码编译成机器码。</li>
            <li><strong>记事本或其他文本编辑器：</strong> 用于编写汇编代码。</li>
            <li><strong>Link.exe：</strong> 微软的链接器，用于将编译后的目标文件链接成可执行文件。通常包含在Visual Studio中。</li>
            <li><strong>调试器：</strong> 例如OllyDbg、x64dbg，用于调试汇编程序。</li>
        </ul>
        <p>
            <strong>安装步骤：</strong>
        </p>
        <ol>
            <li><strong>安装Visual Studio：</strong> 安装Visual Studio Community版本，安装时选择包含C++的组件，这样会自动安装MASM和Link.exe。</li>
            <li><strong>配置环境变量：</strong> 将MASM的bin目录（例如：<code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx86\x86</code>）添加到系统的PATH环境变量中。</li>
            <li><strong>编写代码：</strong> 使用记事本或其他文本编辑器编写汇编代码，保存为<code>.asm</code>文件。</li>
            <li><strong>编译和链接：</strong> 打开命令提示符，使用<code>ml</code>命令编译汇编代码，使用<code>link</code>命令链接生成可执行文件。</li>
            <li><strong>运行和调试：</strong> 直接运行生成的可执行文件，或使用调试器进行调试。</li>
        </ol>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
; hello.asm
.model small
.stack 100h
.data
    msg db 'Hello, world!', 0dh, 0ah, '$'
.code
    main proc
        mov ax, @data
        mov ds, ax
        mov ah, 9
        mov dx, offset msg
        int 21h
        mov ax, 4c00h
        int 21h
    main endp
end main
        </code></pre>
        <p>
            在命令提示符中编译和链接：
        </p>
        <pre><code>
ml hello.asm
link hello.obj
hello.exe
        </code></pre>

        <h3>2.2 Linux</h3>
        <p>
            在Linux上，我们通常使用以下工具：
        </p>
        <ul>
            <li><strong>NASM (Netwide Assembler)：</strong> 一个流行的开源汇编器，支持多种平台和输出格式。</li>
            <li><strong>任何文本编辑器：</strong> 用于编写汇编代码，如Vim、Nano或Gedit。</li>
            <li><strong>GNU链接器：</strong> 用于将编译后的目标文件链接成可执行文件。</li>
            <li><strong>GDB (GNU Debugger)：</strong> 用于调试汇编程序。</li>
        </ul>
        <p>
            <strong>安装步骤：</strong>
        </p>
        <ol>
            <li><strong>安装NASM：</strong> 在终端中运行命令安装NASM，例如：<code>sudo apt-get install nasm</code> (Debian/Ubuntu) 或 <code>sudo yum install nasm</code> (CentOS/RHEL)。</li>
            <li><strong>编写代码：</strong> 使用文本编辑器编写汇编代码，保存为<code>.asm</code>文件。</li>
            <li><strong>编译和链接：</strong> 使用<code>nasm</code>命令编译汇编代码，使用<code>ld</code>命令链接生成可执行文件。</li>
            <li><strong>运行和调试：</strong> 直接运行生成的可执行文件，或使用GDB进行调试。</li>
        </ol>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
; hello.asm
section .data
    msg db 'Hello, world!', 0ah
    len equ $- msg
section .text
    global _start
_start:
    mov eax, 4          ; sys_write
    mov ebx, 1          ; stdout
    mov ecx, msg
    mov edx, len
    int 0x80          ; 调用内核中断
    mov eax, 1          ; sys_exit
    xor ebx, ebx
    int 0x80
        </code></pre>
        <p>
            在终端中编译和链接：
        </p>
        <pre><code>
nasm -f elf hello.asm
ld -m elf_i386 hello.o -o hello
./hello
        </code></pre>

        <h2 id="basic-syntax">3. 汇编语言基础语法</h2>
        <p>
            汇编语言程序由一系列的<strong>语句</strong>组成，每个语句通常占据一行。汇编语句的通用格式如下：
        </p>
        <pre><code>
[标签:]    指令    [操作数1][, 操作数2]    [; 注释]
        </code></pre>
        <p>
            下面详细解释每个部分：
        </p>
        <ul>
            <li><strong>标签（Label）：</strong> 用于标识代码中的一个位置，通常用于跳转指令的目标地址。标签后面跟着一个冒号<code>:</code>。</li>
            <li><strong>指令（Instruction）：</strong> 汇编语言的核心，它指定了要执行的操作，例如<code>MOV</code>（传送数据）、<code>ADD</code>（加法）、<code>JMP</code>（跳转）等。</li>
            <li><strong>操作数（Operand）：</strong> 指令操作的对象，可以是寄存器、内存地址、常数等。不同的指令需要不同数量和类型的操作数。</li>
            <li><strong>注释（Comment）：</strong> 以分号<code>;</code>开始，用于解释代码的功能，不会被汇编器执行。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 10      ; 将常数10移动到eax寄存器
    add ebx, eax     ; 将eax的值加到ebx寄存器
loop_start:
    dec ecx          ; 将ecx寄存器的值减1
    jnz loop_start   ; 如果ecx不为零，则跳转到loop_start标签
        </code></pre>

        <h3>3.1 标识符</h3>
        <p>
            标识符用于表示标签、变量、过程名等。标识符的命名规则如下：
        </p>
        <ul>
            <li>可以包含字母、数字、下划线<code>_</code>和美元符号<code>$</code>。</li>
            <li>必须以字母或下划线开头。</li>
            <li>不能是汇编器的保留字（如<code>MOV</code>、<code>ADD</code>等）。</li>
            <li>长度一般不超过31个字符。</li>
            <li>大小写不敏感（在大多数汇编器中）。</li>
        </ul>
        <p>
            <strong>合法的标识符：</strong>
        </p>
        <pre><code>
    my_variable
    count
    _start
    loop1
    DATA_SEGMENT
        </code></pre>
        <p>
            <strong>非法的标识符：</strong>
        </p>
        <pre><code>
    123var       ; 不能以数字开头
    my var       ; 不能包含空格
    MOV          ; 不能是保留字
        </code></pre>

        <h3>3.2 常数</h3>
        <p>
            汇编语言中可以使用多种类型的常数：
        </p>
        <ul>
            <li><strong>二进制常数：</strong> 以<code>b</code>或<code>B</code>结尾，例如<code>1011b</code>、<code>1101B</code>。</li>
            <li><strong>十进制常数：</strong> 默认的常数类型，例如<code>123</code>、<code>4567</code>。</li>
            <li><strong>十六进制常数：</strong> 以<code>h</code>或<code>H</code>结尾，或者以<code>0x</code>开头，例如<code>7Ah</code>、<code>0x7A</code>、<code>FFH</code>、<code>0xFF</code>。</li>
            <li><strong>八进制常数：</strong> 以<code>o</code>或<code>O</code>结尾，例如<code>77o</code>、<code>123O</code>。</li>
            <li><strong>字符常数：</strong> 用单引号括起来的字符，例如<code>'A'</code>、<code>'b'</code>。</li>
            <li><strong>字符串常数：</strong> 用双引号或单引号括起来的字符串，例如<code>"Hello"</code>、<code>'World'</code>。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov ax, 10          ; 十进制常数
    mov bx, 1101b       ; 二进制常数
    mov cx, 0FFh        ; 十六进制常数
    mov dx, 'A'         ; 字符常数
    msg db "Hello", 0  ; 字符串常数
        </code></pre>

        <h3>3.3 数据定义</h3>
        <p>
            在汇编语言中，可以使用伪指令来定义数据。常用的伪指令包括：
        </p>
        <ul>
            <li><strong>DB (Define Byte)：</strong> 定义字节数据。</li>
            <li><strong>DW (Define Word)：</strong> 定义字（2字节）数据。</li>
            <li><strong>DD (Define Doubleword)：</strong> 定义双字（4字节）数据。</li>
            <li><strong>DQ (Define Quadword)：</strong> 定义四字（8字节）数据。</li>
            <li><strong>DT (Define Ten Bytes)：</strong> 定义十字节数据。</li>
        </ul>
        <p>
            数据定义伪指令通常放在数据段（<code>.data</code>或<code>DATA SEGMENT</code>）中。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
.data
    byte_var db 10      ; 定义一个字节变量，初始值为10
    word_var dw 1000    ; 定义一个字变量，初始值为1000
    dword_var dd 100000 ; 定义一个双字变量，初始值为100000
    message db "Hello, world!", 0  ; 定义一个字符串，以0结尾
    array db 1, 2, 3, 4, 5  ; 定义一个字节数组
    values dw 10, 20, 30, 40 ; 定义一个字数组
        </code></pre>

        <h2 id="memory-registers">4. 内存与寄存器</h2>
        <p>
            计算机的内存用于存储程序和数据，而寄存器是CPU内部用于快速访问和处理数据的存储单元。
        </p>

        <h3>4.1 内存</h3>
        <p>
            内存被组织成一个线性的字节数组，每个字节都有一个唯一的地址，称为<strong>内存地址</strong>。程序可以通过内存地址来访问和操作内存中的数据。
        </p>
        <p>
            在x86汇编中，内存地址通常用十六进制数表示。例如，地址<code>0x1000</code>表示内存中的第4096个字节。
        </p>
        <p>
            <strong>内存模型：</strong>
        </p>
        <p>
            x86架构支持多种内存模型，包括：
        </p>
        <ul>
            <li><strong>平坦模型（Flat Memory Model）：</strong> 整个内存空间被视为一个连续的地址空间，所有程序和数据都位于这个空间中。现代操作系统（如Windows、Linux）通常使用平坦模型。</li>
            <li><strong>分段模型（Segmented Memory Model）：</strong> 内存被分成多个段，每个段有自己的起始地址和长度。程序通过段寄存器（如<code>CS</code>、<code>DS</code>、<code>SS</code>、<code>ES</code>）和偏移地址来访问内存。</li>
        </ul>
        <p>
            在本教程中，我们主要关注平坦模型。
        </p>

        <h3>4.2 寄存器</h3>
        <p>
            x86 CPU包含多种寄存器，用于存储不同类型的数据和控制程序的执行。常用的寄存器可以分为以下几类：
        </p>
        <ul>
            <li><strong>通用寄存器：</strong> 用于存储数据和地址。</li>
            <li><strong>段寄存器：</strong> 用于存储内存段的起始地址（在分段模型中）。</li>
            <li><strong>指令指针寄存器：</strong> 用于存储下一条要执行的指令的地址。</li>
            <li><strong>标志寄存器：</strong> 用于存储指令执行结果的状态信息。</li>
        </ul>

        <h4>4.2.1 通用寄存器</h4>
        <p>
            通用寄存器可以用于存储字节、字或双字数据。常用的通用寄存器包括：
        </p>
        <ul>
            <li><strong>EAX：</strong> 累加器寄存器，常用于算术运算和函数返回值。</li>
            <li><strong>EBX：</strong> 基址寄存器，常用于存储内存地址。</li>
            <li><strong>ECX：</strong> 计数器寄存器，常用于循环操作。</li>
            <li><strong>EDX：</strong> 数据寄存器，常用于I/O操作和乘除法运算。</li>
            <li><strong>ESI：</strong> 源变址寄存器，常用于存储源操作数的地址。</li>
            <li><strong>EDI：</strong> 目标变址寄存器，常用于存储目标操作数的地址。</li>
            <li><strong>ESP：</strong> 栈指针寄存器，指向栈的顶部。</li>
            <li><strong>EBP：</strong> 基指针寄存器，常用于访问栈中的数据。</li>
        </ul>
        <p>
            这些寄存器既可以作为32位寄存器（如<code>EAX</code>、<code>EBX</code>等）使用，也可以作为16位寄存器（如<code>AX</code>、<code>BX</code>等）或8位寄存器（如<code>AH</code>、<code>AL</code>、<code>BH</code>、<code>BL</code>等）使用。
        </p>
        <p>
            <strong>寄存器示意图：</strong>
        </p>
        <img src="https://i.imgur.com/sQ6ub5i.png" alt="x86寄存器" class="center-image">
        <p style="text-align: center;">x86寄存器示意图</p>

        <h4>4.2.2 段寄存器</h4>
        <p>
            在分段模型中，段寄存器用于存储内存段的起始地址。常用的段寄存器包括：
        </p>
        <ul>
            <li><strong>CS (Code Segment Register)：</strong> 代码段寄存器，指向包含程序代码的内存段。</li>
            <li><strong>DS (Data Segment Register)：</strong> 数据段寄存器，指向包含程序数据的内存段。</li>
            <li><strong>SS (Stack Segment Register)：</strong> 栈段寄存器，指向包含程序栈的内存段。</li>
            <li><strong>ES (Extra Segment Register)：</strong> 附加段寄存器，指向额外的内存段。</li>
<li><strong>FS、GS：</strong> 附加的段寄存器，用于访问特定的内存区域。</li>
        </ul>
        <p>
            在平坦模型中，段寄存器的作用相对较小，通常将<code>DS</code>设置为与<code>CS</code>相同的值。
        </p>

        <h4>4.2.3 指令指针寄存器</h4>
        <p>
            <strong>EIP (Extended Instruction Pointer)：</strong> 指令指针寄存器存储下一条要执行的指令的地址。CPU根据EIP的值来顺序执行程序中的指令。
        </p>

        <h4>4.2.4 标志寄存器</h4>
        <p>
            <strong>EFLAGS (Extended Flags Register)：</strong> 标志寄存器包含了一组标志位，用于存储指令执行结果的状态信息。常用的标志位包括：
        </p>
        <ul>
            <li><strong>CF (Carry Flag)：</strong> 进位标志，表示算术运算是否产生了进位或借位。</li>
            <li><strong>ZF (Zero Flag)：</strong> 零标志，表示运算结果是否为零。</li>
            <li><strong>SF (Sign Flag)：</strong> 符号标志，表示运算结果的符号（最高位是否为1）。</li>
            <li><strong>OF (Overflow Flag)：</strong> 溢出标志，表示有符号算术运算是否发生了溢出。</li>
            <li><strong>PF (Parity Flag)：</strong> 奇偶标志，表示运算结果中1的个数是奇数还是偶数。</li>
            <li><strong>AF (Auxiliary Carry Flag)：</strong> 辅助进位标志，用于BCD运算。</li>
            <li><strong>DF (Direction Flag)：</strong> 方向标志，用于控制字符串操作指令（如<code>MOVS</code>、<code>CMPS</code>）的读写方向。</li>
            <li><strong>IF (Interrupt Enable Flag)：</strong> 中断允许标志，控制CPU是否响应外部中断。</li>
        </ul>
        <p>
            标志位的值可以被一些指令（如<code>JCC</code>条件跳转指令）用来控制程序的执行流程。
        </p>

        <h2 id="addressing-modes">5. 寻址方式</h2>
        <p>
            寻址方式是指CPU在执行指令时如何定位操作数的方法。x86汇编语言支持多种寻址方式，包括：
        </p>
        <ul>
            <li><strong>立即寻址（Immediate Addressing）：</strong> 操作数是指令的一部分，直接给出常数值。</li>
            <li><strong>寄存器寻址（Register Addressing）：</strong> 操作数是寄存器。</li>
            <li><strong>直接寻址（Direct Addressing）：</strong> 操作数是内存地址，直接给出内存地址的数值。</li>
            <li><strong>间接寻址（Indirect Addressing）：</strong> 操作数是寄存器，寄存器中存储的是内存地址。</li>
            <li><strong>基址寻址（Base Addressing）：</strong> 操作数是基址寄存器（如<code>EBX</code>、<code>EBP</code>）加上偏移量。</li>
            <li><strong>变址寻址（Indexed Addressing）：</strong> 操作数是变址寄存器（如<code>ESI</code>、<code>EDI</code>）加上比例因子和偏移量。</li>
            <li><strong>相对寻址（Relative Addressing）：</strong> 操作数是当前指令地址加上偏移量，常用于跳转指令。</li>
        </ul>

        <h3>5.1 立即寻址</h3>
        <p>
            在立即寻址方式中，操作数是指令的一部分，直接给出常数值。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 10      ; 将常数10移动到eax寄存器
    add ebx, 20      ; 将常数20加到ebx寄存器
        </code></pre>

        <h3>5.2 寄存器寻址</h3>
        <p>
            在寄存器寻址方式中，操作数是寄存器。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, ebx     ; 将ebx寄存器的值移动到eax寄存器
    add eax, ecx     ; 将ecx寄存器的值加到eax寄存器
        </code></pre>

        <h3>5.3 直接寻址</h3>
        <p>
            在直接寻址方式中，操作数是内存地址，直接给出内存地址的数值。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
.data
    my_var dd 12345
.code
    mov eax, my_var  ; 将内存地址my_var处的值移动到eax寄存器
        </code></pre>

        <h3>5.4 间接寻址</h3>
        <p>
            在间接寻址方式中，操作数是寄存器，寄存器中存储的是内存地址。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
.data
    my_var dd 12345
.code
    mov ebx, offset my_var ; 将my_var的地址存储到ebx寄存器
    mov eax, [ebx]       ; 将ebx寄存器指向的内存地址处的值移动到eax寄存器
        </code></pre>
        <p>
            在上面的例子中，<code>[ebx]</code>表示<code>ebx</code>寄存器中的值所指向的内存地址。
        </p>

        <h3>5.5 基址寻址</h3>
        <p>
            在基址寻址方式中，操作数是基址寄存器（如<code>EBX</code>、<code>EBP</code>）加上偏移量。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
.data
    my_array db 10, 20, 30, 40, 50
.code
    mov ebx, offset my_array ; 将my_array的地址存储到ebx寄存器
    mov al, [ebx + 2]      ; 将my_array[2]的值（即30）移动到al寄存器
        </code></pre>
        <p>
            在上面的例子中，<code>[ebx + 2]</code>表示<code>ebx</code>寄存器中的值加上偏移量2所指向的内存地址。
        </p>

        <h3>5.6 变址寻址</h3>
        <p>
            在变址寻址方式中，操作数是变址寄存器（如<code>ESI</code>、<code>EDI</code>）加上比例因子和偏移量。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
.data
    my_array dd 10, 20, 30, 40, 50
.code
    mov esi, 2          ; 变址寄存器esi的值为2
    mov eax, [my_array + esi * 4] ; 将my_array[esi]的值（即30）移动到eax寄存器
        </code></pre>
         <p>
            比例因子可以是1、2、4或8，用于计算偏移量。  在上面的例子中，比例因子是4，因为数组中的每个元素是4字节（双字）。
        </p>

        <h3>5.7 相对寻址</h3>
        <p>
            在相对寻址方式中，操作数是当前指令地址加上偏移量，常用于跳转指令。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    jmp short target    ; 短跳转到标签target
    ; ...
target:
    mov eax, 10
        </code></pre>
        <p>
            在上面的例子中，<code>jmp short target</code>指令将程序执行流程跳转到标签<code>target</code>处的指令。跳转的目标地址是相对于当前指令的地址加上偏移量计算得到的。
        </p>

        <h2 id="instructions">6. 汇编指令</h2>
        <p>
            汇编指令是CPU执行的基本操作。x86汇编语言提供了丰富的指令集，可以完成各种不同的任务。
        </p>

        <h3>6.1 数据传送指令</h3>
        <p>
            数据传送指令用于在寄存器和内存之间传送数据。常用的数据传送指令包括：
        </p>
        <ul>
            <li><strong>MOV (Move)：</strong> 将数据从一个位置复制到另一个位置。</li>
            <li><strong>PUSH (Push)：</strong> 将数据压入栈中。</li>
            <li><strong>POP (Pop)：</strong> 从栈中弹出数据。</li>
            <li><strong>LEA (Load Effective Address)：</strong> 将内存地址加载到寄存器中。</li>
            <li><strong>XCHG (Exchange)：</strong> 交换两个操作数的值。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 10      ; 将常数10移动到eax寄存器
    mov ebx, eax     ; 将eax寄存器的值移动到ebx寄存器
    push eax         ; 将eax寄存器的值压入栈中
    pop ecx          ; 从栈中弹出数据到ecx寄存器
    lea edi, my_var  ; 将my_var的地址加载到edi寄存器
    xchg eax, ebx    ; 交换eax和ebx寄存器的值
        </code></pre>

        <h3>6.2 算术运算指令</h3>
        <p>
            算术运算指令用于执行加、减、乘、除等运算。常用的算术运算指令包括：
        </p>
        <ul>
            <li><strong>ADD (Add)：</strong> 加法。</li>
            <li><strong>SUB (Subtract)：</strong> 减法。</li>
            <li><strong>MUL (Multiply)：</strong> 乘法（无符号数）。</li>
            <li><strong>IMUL (Signed Multiply)：</strong> 乘法（有符号数）。</li>
            <li><strong>DIV (Divide)：</strong> 除法（无符号数）。</li>
            <li><strong>IDIV (Signed Divide)：</strong> 除法（有符号数）。</li>
            <li><strong>INC (Increment)：</strong> 加1。</li>
            <li><strong>DEC (Decrement)：</strong> 减1。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 10
    mov ebx, 20
    add eax, ebx     ; eax = eax + ebx = 30
    sub eax, 5       ; eax = eax - 5 = 25
    mov ecx, 3
    mul ecx          ; edx:eax = eax * ecx = 75  (eax存储结果的低32位，edx存储高32位)
    mov edx, 0
    mov ebx, 2
    div ebx          ; eax = (edx:eax) / ebx = 37, edx = (edx:eax) % ebx = 1
    inc eax          ; eax = eax + 1 = 38
    dec ebx          ; ebx = ebx - 1 = 0
        </code></pre>
        <p>
            <strong>注意：</strong>
        </p>
        <ul>
            <li><code>MUL</code>和<code>IMUL</code>指令的结果存储在<code>EDX:EAX</code>寄存器对中，其中<code>EAX</code>存储结果的低32位，<code>EDX</code>存储结果的高32位。</li>
            <li><code>DIV</code>和<code>IDIV</code>指令的被除数存储在<code>EDX:EAX</code>寄存器对中，除数作为指令的操作数。  商存储在<code>EAX</code>中，余数存储在<code>EDX</code>中。</li>
        </ul>

        <h3>6.3 位操作指令</h3>
        <p>
            位操作指令用于对数据的二进制位进行操作。常用的位操作指令包括：
        </p>
        <ul>
            <li><strong>AND (Logical AND)：</strong> 逻辑与。</li>
            <li><strong>OR (Logical OR)：</strong> 逻辑或。</li>
            <li><strong>XOR (Logical Exclusive OR)：</strong> 逻辑异或。</li>
            <li><strong>NOT (Logical NOT)：</strong> 逻辑非。</li>
            <li><strong>SHL (Shift Left)：</strong> 左移。</li>
            <li><strong>SHR (Shift Right)：</strong> 右移（无符号数）。</li>
            <li><strong>SAR (Shift Arithmetic Right)：</strong> 算术右移（有符号数）。</li>
            <li><strong>ROL (Rotate Left)：</strong> 循环左移。</li>
            <li><strong>ROR (Rotate Right)：</strong> 循环右移。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 0x0F    ; eax = 00001111b
    mov ebx, 0x3C    ; ebx = 00111100b
    and eax, ebx    ; eax = eax & ebx = 00001100b = 0x0C
    or eax, 0x03     ; eax = eax | 0x03 = 00001111b = 0x0F
    xor eax, ebx    ; eax = eax ^ ebx = 00110011b = 0x33
    not eax         ; eax = ~eax = 11001100b = 0xCC
    mov ecx, 2
    shl eax, cl     ; eax = eax << cl = 11001100b << 2 = 00110000b = 0x30
    shr eax, cl     ; eax = eax >> cl = 00110000b >> 2 = 00001100b = 0x0C
    sar eax, cl     ; eax = eax >> cl (带符号)
    rol eax, cl     ; eax 循环左移2位
    ror eax, cl     ; eax 循环右移2位
        </code></pre>

        <h3>6.4 控制转移指令</h3>
        <p>
            控制转移指令用于改变程序的执行流程。常用的控制转移指令包括：
        </p>
        <ul>
            <li><strong>JMP (Jump)：</strong> 无条件跳转。</li>
            <li><strong>JCC (Conditional Jump)：</strong> 条件跳转，根据标志位的值来决定是否跳转。</li>
            <li><strong>CALL (Call)：</strong> 调用过程（函数）。</li>
            <li><strong>RET (Return)：</strong> 从过程（函数）返回。</li>
            <li><strong>LOOP (Loop)：</strong> 循环指令，根据<code>ECX</code>寄存器的值来控制循环次数。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov ecx, 10
loop_start:
    ; 循环体
    dec ecx
    jnz loop_start   ; 如果ecx不为零，则跳转到loop_start
    jmp target       ; 无条件跳转到target
target:
    mov eax, 10
    call my_proc     ; 调用过程my_proc
    ; ...
my_proc:
    ; 过程体
    ret            ; 从过程返回
        </code></pre>
        <p>
            <strong>常用的条件跳转指令：</strong>
        </p>
        <ul>
            <li><code>JE</code> / <code>JZ</code>：等于 / 为零时跳转 (ZF = 1)。</li>
            <li><code>JNE</code> / <code>JNZ</code>：不等于 / 不为零时跳转 (ZF = 0)。</li>
            <li><code>JG</code> / <code>JNLE</code>：大于 / 不小于等于时跳转 (SF = OF 且 ZF = 0)。</li>
            <li><code>JGE</code> / <code>JNL</code>：大于等于 / 不小于时跳转 (SF = OF)。</li>
            <li><code>JL</code> / <code>JNGE</code>：小于 / 不大于等于时跳转 (SF ≠ OF)。</li>
            <li><code>JLE</code> / <code>JNG</code>：小于等于 / 不大于时跳转 (SF ≠ OF 或 ZF = 1)。</li>
            <li><code>JC</code>：进位时跳转 (CF = 1)。</li>
            <li><code>JNC</code>：不进位时跳转 (CF = 0)。</li>
            <li><code>JO</code>：溢出时跳转 (OF = 1)。</li>
            <li><code>JNO</code>：不溢出时跳转 (OF = 0)。</li>
            <li><code>JP</code> / <code>JPE</code>：奇偶位为偶数时跳转 (PF = 1)。</li>
            <li><code>JNP</code> / <code>JPO</code>：奇偶位为奇数时跳转 (PF = 0)。</li>
        </ul>

        <h3>6.5 比较指令</h3>
        <p>
            比较指令用于比较两个操作数的大小，并设置标志寄存器的值。常用的比较指令包括：
        </p>
        <ul>
            <li><strong>CMP (Compare)：</strong> 比较两个操作数的值。</li>
            <li><strong>TEST (Test)：</strong> 比较两个操作数的位，常用于检查特定位是否为1。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 10
    mov ebx, 20
    cmp eax, ebx    ; 比较eax和ebx的值，设置标志位
    jg greater      ; 如果eax > ebx，则跳转到greater
    ; ...
greater:
    mov ecx, 1
    test ecx, 1     ; 检查ecx的最低位是否为1
    jnz is_one      ; 如果ecx的最低位为1，则跳转到is_one
    ; ...
is_one:
    mov edx, 1
        </code></pre>
        <p>
            <code>CMP</code>指令的操作数与<code>SUB</code>指令相同，但<code>CMP</code>指令不改变操作数的值，只设置标志位。  <code>TEST</code>指令的操作数与<code>AND</code>指令相同，但不改变操作数的值，只设置标志位。
        </p>

        <h3>6.6 字符串操作指令</h3>
        <p>
            字符串操作指令用于处理字符串数据。常用的字符串操作指令包括：
        </p>
        <ul>
            <li><strong>MOVS (Move String)：</strong> 传送字符串。</li>
            <li><strong>CMPS (Compare String)：</strong> 比较字符串。</li>
            <li><strong>SCAS (Scan String)：</strong> 扫描字符串。</li>
            <li><strong>LODS (Load String)：</strong> 加载字符串。</li>
            <li><strong>STOS (Store String)：</strong> 存储字符串。</li>
        </ul>
        <p>
            这些指令通常与<code>REP</code>（重复）、<code>REPE</code> / <code>REPZ</code>（相等时重复）、<code>REPNE</code> / <code>REPNZ</code>（不相等时重复）前缀一起使用，以处理整个字符串。  使用这些指令时，需要设置<code>ESI</code>（源地址）、<code>EDI</code>（目标地址）、<code>ECX</code>（计数器）和<code>DF</code>（方向标志）寄存器。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
.data
    src_str db "Hello", 0
    dst_str db 6 dup(0)
.code
    mov esi, offset src_str
    mov edi, offset dst_str
    mov ecx, 5
    cld             ; 设置方向标志为向上（从低地址到高地址）
    rep movsb       ; 复制src_str到dst_str
    mov esi, offset src_str
    mov edi, offset src_str
    mov ecx, 5
    cld
    repe cmpsb      ; 比较两个字符串，相等则继续比较
    je equal_str
    ; ...
equal_str:
    mov eax, 1
        </code></pre>

        <h3>6.7 I/O指令</h3>
        <p>
            I/O指令用于与外部设备进行数据交换。常用的I/O指令包括：
        </p>
        <ul>
            <li><strong>IN (Input)：</strong> 从I/O端口读取数据。</li>
            <li><strong>OUT (Output)：</strong> 向I/O端口写入数据。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov dx, 0x3F8    ; 串口1的数据端口地址
    mov al, 'A'
    out dx, al       ; 将字符'A'写入串口
    in al, dx        ; 从串口读取一个字符到al
        </code></pre>
        <p>
            I/O端口地址通常是16位的，存储在<code>DX</code>寄存器中。  <code>IN</code>和<code>OUT</code>指令只能使用<code>AX</code>或<code>AL</code>寄存器来传送数据。
        </p>

        <h2 id="procedures">7. 过程（函数）</h2>
        <p>
            过程（Procedure）是汇编语言中的一个独立的代码块，用于完成特定的任务。过程类似于高级语言中的函数。使用过程可以将程序分解成更小的、易于管理的部分，提高代码的模块性和可重用性。
        </p>

        <h3>7.1 定义过程</h3>
        <p>
            在汇编语言中，使用<code>PROC</code>和<code>ENDP</code>伪指令来定义过程。过程的通用格式如下：
        </p>
        <pre><code>
过程名 PROC [NEAR | FAR]
    ; 过程体
    RET
过程名 ENDP
        </code></pre>
        <ul>
            <li><code>过程名</code>：过程的名称，遵循标识符的命名规则。</li>
            <li><code>NEAR</code>或<code>FAR</code>：指定过程的调用方式。<code>NEAR</code>表示近调用，用于段内调用；<code>FAR</code>表示远调用，用于段间调用。在平坦模型中，通常使用<code>NEAR</code>。</li>
            <li><code>RET</code>：返回指令，用于从过程返回到调用者。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
; 计算两个数的和的过程
add_numbers PROC NEAR
    mov eax, [esp + 4]  ; 获取第一个参数
    mov ebx, [esp + 8]  ; 获取第二个参数
    add eax, ebx
    ret                 ; 返回，结果在eax中
add_numbers ENDP
        </code></pre>

        <h3>7.2 调用过程</h3>
        <p>
            使用<code>CALL</code>指令来调用过程。调用过程时，需要将过程的参数压入栈中，然后执行<code>CALL</code>指令。<code>CALL</code>指令会将返回地址（调用指令的下一条指令的地址）压入栈中，然后跳转到过程的起始地址执行。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    push 10           ; 将第一个参数压入栈中
    push 20           ; 将第二个参数压入栈中
    call add_numbers  ; 调用add_numbers过程
    add esp, 8        ; 调整栈指针，清除参数
    ; 此时，eax中存储着计算结果30
        </code></pre>

        <h3>7.3 过程中的参数传递</h3>
        <p>
            在汇编语言中，常用的参数传递方式有两种：
        </p>
        <ul>
            <li><strong>通过栈传递参数：</strong> 调用者将参数压入栈中，过程通过栈指针<code>ESP</code>来访问参数。</li>
            <li><strong>通过寄存器传递参数：</strong> 调用者将参数放入寄存器中，过程直接从寄存器中获取参数。</li>
        </ul>
        <p>
            上面的示例中使用了通过栈传递参数的方式。  下面是一个使用寄存器传递参数的示例：
        </p>
        <pre><code>
; 计算两个数的和的过程（使用寄存器传递参数）
add_numbers_reg PROC NEAR
    add eax, ebx     ; 结果在eax中
    ret
add_numbers_reg ENDP

    mov eax, 10
    mov ebx, 20
    call add_numbers_reg
    ; 此时，eax中存储着计算结果30
        </code></pre>

        <h3>7.4 局部变量</h3>
        <p>
            过程可以使用栈来分配和管理局部变量。在过程的开始，通过移动栈指针<code>ESP</code>来为局部变量分配空间；在过程的结束，通过恢复<code>ESP</code>的值来释放局部变量的空间。
        </p>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
my_proc PROC NEAR
    push ebp          ; 保存ebp
    mov ebp, esp      ; 设置ebp为栈底指针
    sub esp, 8        ; 为局部变量分配8字节空间
    ; 使用ebp来访问局部变量
    mov [ebp - 4], 10  ; 将10存储到第一个局部变量
    mov [ebp - 8], 20  ; 将20存储到第二个局部变量
    ; ...
    mov esp, ebp      ; 恢复esp
    pop ebp           ; 恢复ebp
    ret
my_proc ENDP
        </code></pre>
        <p>
            在上面的例子中，<code>EBP</code>寄存器用作栈帧指针，指向当前过程的栈帧的底部。  局部变量通过相对于<code>EBP</code>的偏移量来访问。
        </p>

        <h2 id="stack">8. 栈</h2>
        <p>
            栈是一种特殊的内存区域，用于存储临时数据、函数调用时的返回地址、参数和局部变量。栈采用<strong>后进先出（LIFO）</strong> 的原则，即最后压入栈的数据最先被弹出。
        </p>

        <h3>8.1 栈的结构</h3>
        <p>
            在x86架构中，栈位于内存的某个区域，由<code>SS</code>（栈段寄存器）和<code>ESP</code>（栈指针寄存器）来管理。<code>SS</code>寄存器存储栈段的起始地址，<code>ESP</code>寄存器存储栈顶的地址。
        </p>
        <p>
            栈的增长方向是<strong>向下</strong> 的，即每压入一个数据，<code>ESP</code>的值就会减小；每弹出一个数据，<code>ESP</code>的值就会增大。
        </p>
        <p>
           <strong>栈的示意图：</strong>
        </p>
        <img src="https://i.imgur.com/KzKzE6i.png" alt="栈的结构" class="center-image">
        <p style="text-align: center;">栈的结构</p>

        <h3>8.2 栈的操作</h3>
        <p>
            栈的基本操作有两个：
        </p>
        <ul>
            <li><strong>压栈（Push）：</strong> 将数据压入栈中。使用<code>PUSH</code>指令将数据压入栈中，<code>ESP</code>的值会减小。</li>
            <li><strong>弹栈（Pop）：</strong> 从栈中弹出数据。使用<code>POP</code>指令从栈中弹出数据，<code>ESP</code>的值会增大。</li>
        </ul>
        <p>
            <strong>示例：</strong>
        </p>
        <pre><code>
    mov eax, 10
    push eax      ; 将eax的值压入栈中，esp = esp - 4
    mov ebx, 20
    push ebx      ; 将ebx的值压入栈中，esp = esp - 4
    pop ecx       ; 从栈中弹出数据到ecx，esp = esp + 4，ecx = 20
    pop edx       ; 从栈中弹出数据到edx，esp = esp + 4，edx = 10
        </code></pre>

        <h3>8.3 栈的应用</h3>
        <p>
            栈在程序中有着广泛的应用，包括：
        </p>
        <ul>
            <li><strong>保存返回地址：</strong> 调用过程时，<code>CALL</code>指令会将返回地址压入栈中，<code>RET</code>指令会从栈中弹出返回地址，使程序返回到调用者的执行位置。</li>
            <li><strong>传递参数：</strong> 调用过程时，可以将参数压入栈中，过程通过栈指针<code>ESP</code>来访问参数。</li>
            <li><strong>存储局部变量：</strong> 过程可以使用栈来分配和管理局部变量的空间。</li>
            <li><strong>保护寄存器：</strong> 在过程的开始，可以将一些寄存器的值压入栈中，在过程的结束，再从栈中弹出这些值，以保护寄存器的值不被破坏。</li>
            <li><strong>中断处理：</strong> 发生中断时，CPU会将一些寄存器的值（如<code>EFLAGS</code>、<code>CS</code>、<code>EIP</code>）压入栈中，中断处理程序执行完毕后，再从栈中弹出这些值，使程序能够恢复执行。</li>
        </ul>

        <h2 id="input-output">9. 输入输出</h2>
        <p>
            程序需要与外部世界进行数据交换，这就涉及到输入输出（I/O）操作。汇编语言提供了多种方式来进行I/O操作。
        </p>

        <h3>9.1 BIOS中断</h3>
        <p>
            BIOS（基本输入输出系统）是计算机启动时运行的一段程序，它提供了一些基本的I/O功能。程序可以通过调用BIOS中断来进行I/O操作。
        </p>
        <p>
            常用的BIOS中断包括：
        </p>
        <ul>
            <li><strong>INT 10h：</strong> 视频服务中断，用于控制显示器的输出。</li>
            <li><strong>INT 16h：</strong> 键盘服务中断，用于从键盘读取输入。</li>
            <li><strong>INT 17h：</strong> 打印机服务中断，用于向打印机输出数据。</li>
            <li><strong>INT 21h：</strong> DOS服务中断，提供更多的I/O和文件操作功能（在DOS系统中）。</li>
        </ul>
        <p>
            <strong>示例（使用INT 10h显示字符）：</strong>
        </p>
        <pre><code>
    mov ah, 0x0e    ; 设置功能号为0x0e（显示字符）
    mov al, 'A'     ; 设置要显示的字符
    int 0x10        ; 调用INT 10h中断
        </code></pre>
        <p>
            <strong>示例（使用INT 16h读取键盘输入）：</strong>
        </p>
        <pre><code>
    mov ah, 0x00    ; 设置功能号为0x00（读取键盘字符）
    int 0x16        ; 调用INT 16h中断
    ; 此时，al寄存器中存储着按下的键的ASCII码
        </code></pre>

        <h3>9.2 DOS中断</h3>
        <p>
            DOS操作系统提供了一组中断服务程序，可以通过<code>INT 21h</code>中断来调用。DOS中断提供了更多的I/O和文件操作功能。
        </p>
        <p>
            <strong>示例（使用INT 21h显示字符串）：</strong>
        </p>
        <pre><code>
.data
    msg db "Hello, world!", '$'
.code
    mov ah, 0x09    ; 设置功能号为0x09（显示字符串）
    mov dx, offset msg ; 设置要显示的字符串的地址
    int 0x21        ; 调用INT 21h中断
        </code></pre>
         <p>
            <strong>示例（使用INT 21h读取字符串）：</strong>
         </p>
         <pre><code>
.data
    buffer db 256 dup(0) ; 定义一个256字节的缓冲区
.code
    mov ah, 0x0a    ; 设置功能号为0x0a (带缓冲区的字符串输入)
    mov dx, offset buffer ; 设置缓冲区地址
    int 0x21
    ; 用户输入的字符串存储在buffer中，buffer的第一个字节是最大长度，第二个字节是实际输入的长度，从第三个字节开始是输入的字符串
         </code></pre>

        <h3>9.3 I/O端口</h3>
        <p>
            除了使用中断，程序还可以直接通过I/O端口与外部设备进行数据交换。每个I/O设备都有若干个端口，程序可以通过<code>IN</code>和<code>OUT</code>指令来读写这些端口。
        </p>
        <p>
            <strong>示例（使用OUT指令向端口写入数据）：</strong>
        </p>
        <pre><code>
    mov dx, 0x3F8    ; 串口1的数据端口地址
    mov al, 'A'     ; 设置要发送的字符
    out dx, al       ; 将字符'A'写入串口
        </code></pre>
        <p>
            <strong>示例（使用IN指令从端口读取数据）：</strong>
        </p>
        <pre><code>
    mov dx, 0x3F8    ; 串口1的数据端口地址
    in al, dx        ; 从串口读取一个字符到al
        </code></pre>
        <p>
            使用I/O端口需要了解设备的硬件接口规范，通常用于直接控制硬件设备。
        </p>

        <h2 id="interrupts">10. 中断</h2>
        <p>
            中断是一种特殊的事件，它会中断CPU的正常执行流程，使CPU转去处理特定的任务。中断可以来自硬件设备（硬件中断）或软件程序（软件中断）。
        </p>

        <h3>10.1 中断的分类</h3>
        <p>
            中断可以分为以下两类：
        </p>
        <ul>
            <li><strong>硬件中断：</strong> 由外部硬件设备（如键盘、鼠标、定时器等）产生的中断。硬件中断通过CPU的<code>INTR</code>引脚发送给CPU。</li>
            <li><strong>软件中断：</strong> 由程序使用<code>INT</code>指令产生的中断。软件中断用于调用操作系统或BIOS提供的服务程序。</li>
        </ul>

        <h3>10.2 中断处理过程</h3>
        <p>
            当CPU接收到中断信号时，它会执行以下操作：
        </p>
        <ol>
            <li>保存当前程序的执行状态（如<code>EFLAGS</code>、<code>CS</code>、<code>EIP</code>寄存器的值）到栈中。</li>
            <li>根据中断类型号（中断向量），从中断向量表中找到相应的中断处理程序的入口地址。</li>
            <li>跳转到中断处理程序的入口地址执行。</li>
            <li>中断处理程序执行完毕后，使用<code>IRET</code>（中断返回）指令从栈中恢复之前保存的执行状态，使程序能够继续执行。</li>
        </ol>

        <h3>10.3 中断向量表</h3>
        <p>
            中断向量表是一个存储中断处理程序入口地址的表格，它位于内存的起始位置（通常在<code>0x00000</code>到<code>0x003FF</code>地址范围内）。每个中断类型号对应一个中断向量，其中存储着相应的中断处理程序的段地址和偏移地址。
        </p>

        <h3>10.4 编写中断处理程序</h3>
        <p>
            编写中断处理程序需要遵循一定的规范：
        </p>
        <ul>
            <li>保存被中断程序使用的寄存器的值到栈中。</li>
            <li>执行中断处理操作。</li>
            <li>恢复之前保存的寄存器的值。</li>
            <li>使用<code>IRET</code>指令返回。</li>
            <li>中断处理程序的最后必须使用<code>IRET</code>指令，而不是<code>RET</code>指令。<code>IRET</code>指令会恢复之前压入栈中的<code>EFLAGS</code>、<code>CS</code>和<code>EIP</code>的值。</li>
        </ul>
        <p>
            <strong>示例（一个简单的中断处理程序）：</strong>
        </p>
        <pre><code>
; 中断处理程序
my_interrupt_handler PROC FAR
    pusha           ; 保存所有通用寄存器
    ; 中断处理代码
    mov al, 'I'
    mov ah, 0x0e
    int 0x10
    popa            ; 恢复所有通用寄存器
    iret            ; 中断返回
my_interrupt_handler ENDP

; 将中断处理程序的入口地址写入中断向量表
.data
    ; 假设中断类型号为0x80
    int_vector dd my_interrupt_handler
.code
    mov ax, seg int_vector
    mov es, ax
    mov edi, 0x80 * 4 ; 中断向量表中偏移量 = 中断类型号 * 4
    mov eax, dword ptr int_vector
    mov [es:edi], eax ; 将中断处理程序的地址写入中断向量表
    ; 设置中断处理程序
    mov al, 0x80
    out 0x21, al ; 设置8259A芯片的IMR，允许IRQ0中断
    sti  ; 允许CPU响应中断
        </code></pre>
        <p>
            上面的例子中，中断处理程序的入口地址被写入中断向量表的<code>0x80 * 4</code>的位置，然后设置中断控制器允许中断，并打开CPU的中断允许标志。当发生中断时，CPU会跳转到<code>my_interrupt_handler</code>处执行。
        </p>

        <h2 id="advanced-topics">11. 高级主题</h2>
        <p>
            本节介绍一些汇编语言的高级主题，包括：
        </p>
        <ul>
            <li>宏</li>
            <li>链接库</li>
            <li>内联汇编</li>
        </ul>

        <h3>11.1 宏</h3>
        <p>
            宏是一种预处理指令，用于定义一段可重复使用的代码片段。宏可以接受参数，并在汇编时展开成实际的汇编代码。使用宏可以简化代码的编写，提高代码的可读性和可维护性。
        </p>
        <p>
            <strong>定义宏：</strong>
        </p>
        <p>
            在MASM中，使用<code>MACRO</code>和<code>ENDM</code>伪指令来定义宏。
        </p>
        <pre><code>
宏名 MACRO [参数1, 参数2, ...]
    ; 宏体
ENDM
        </code></pre>
        <p>
            <strong>调用宏：</strong>
        </p>
        <p>
            调用宏就像调用指令一样，给出宏名和参数。
        </p>
        <p>
           <strong>示例：</strong>
        </p>
        <pre><code>
; 定义一个宏，用于将一个值移动到寄存器
mov_reg MACRO reg, value
    mov reg, value
ENDM

    mov_reg eax, 10    ; 展开为：mov eax, 10
    mov_reg ebx, 20    ; 展开为：mov ebx, 20
        </code></pre>
        <p>
            <strong>带局部变量的宏：</strong>
        </p>
        <p>
            宏可以使用<code>LOCAL</code>伪指令来定义局部变量，以避免与其他标识符冲突。
        </p>
        <pre><code>
my_macro MACRO param
    LOCAL my_label
    ; ...
my_label:
    ; ...
ENDM
        </code></pre>

        <h3>11.2 链接库</h3>
        <p>
            链接库（Library）是一些预先编译好的代码模块，可以被多个程序共享。使用链接库可以避免重复编写常用的代码，提高开发效率。
        </p>
        <p>
            链接库分为静态链接库和动态链接库两种：
        </p>
        <ul>
            <li><strong>静态链接库（.lib）：</strong> 在编译时将库的代码复制到可执行文件中，生成的可执行文件包含库的代码，因此体积较大，但运行时不需要额外的文件。</li>
            <li><strong>动态链接库（.dll）：</strong> 在运行时才加载到内存中，多个程序可以共享同一个DLL文件，节省内存空间，但运行时需要提供相应的DLL文件。</li>
        </ul>
        <p>
            <strong>使用链接库：</strong>
        </p>
        <p>
            在汇编程序中使用链接库，需要使用<code>EXTERN</code>伪指令声明库中要使用的函数，然后使用链接器将库链接到可执行文件中。
        </p>
        <p>
            <strong>示例（使用C标准库的printf函数）：</strong>
        </p>
        <pre><code>
extern printf   ; 声明printf函数

.data
    msg db "Hello, world!", 0
.code
    push offset msg
    call printf
    add esp, 4
        </code></pre>
        <p>
            上面的例子中，使用<code>EXTERN</code>伪指令声明了<code>printf</code>函数，然后在程序中调用了该函数。  编译链接时需要链接C标准库。
        </p>

        <h3>11.3 内联汇编</h3>
        <p>
            内联汇编是指将汇编代码直接嵌入到高级语言（如C、C++）代码中。使用内联汇编可以在高级语言程序中直接使用汇编指令，以实现一些特定的功能或进行性能优化。
        </p>
        <p>
            <strong>示例（在C++中使用内联汇编）：</strong>
        </p>
        <pre><code>
#include <iostream>
using namespace std;

int main() {
    int a = 10, b = 20, c;
    __asm {
        mov eax, a
        mov ebx, b
        add eax, ebx
        mov c, eax
    }
    cout << "c = " << c << endl;
    return 0;
}
        </code></pre>
        <p>
            上面的例子中，使用<code>__asm</code>关键字将汇编代码嵌入到C++程序中，计算了<code>a</code>和<code>b</code>的和，并将结果存储到<code>c</code>中。
        </p>

        <h2 id="exercises">12. 综合练习</h2>
        <p>
            本节提供一些综合性的练习题，帮助你巩固所学的知识，提高汇编语言的编程能力。
        </p>

        <div class="exercise">
            <h4>练习1：计算数组元素的和</h4>
            <p>
                编写一个汇编程序，计算一个整数数组的所有元素的和，并将结果存储在<code>EAX</code>寄存器中。
            </p>
        </div>

        <div class="solution">
            <h4>解答：</h4>
            <pre><code>
.data
    array dd 1, 2, 3, 4, 5
    len equ ($ - array) / 4
.code
    mov eax, 0      ; 初始化和为0
    mov ecx, len    ; 设置循环次数
    mov esi, offset array ; 设置数组首地址
loop_start:
    add eax, [esi]  ; 将当前元素加到和中
    add esi, 4      ; 指向下一个元素
    loop loop_start ; 循环
    ; 结果存储在eax中
            </code></pre>
        </div>

        <div class="exercise">
            <h4>练习2：字符串反转</h4>
            <p>
                编写一个汇编程序，将一个字符串反转，并将反转后的字符串存储在另一个内存区域中。
            </p>
        </div>

        <div class="solution">
            <h4>解答：</h4>
            <pre><code>
.data
    src_str db "hello", 0
    dst_str db 6 dup(0)
.code
    mov esi, offset src_str
    mov edi, offset dst_str
    mov ecx, 0
; 计算字符串长度
str_len_loop:
    cmp byte ptr [esi + ecx], 0
    jz str_len_end
    inc ecx
    jmp str_len_loop
str_len_end:
    dec ecx ; ecx现在是字符串长度，不包括null terminator
    mov ebx, ecx ; ebx保存字符串长度
reverse_loop:
    mov al, [esi + ecx]
    mov [edi + ebx - ecx], al
    loop reverse_loop
            </code></pre>
        </div>

        <div class="exercise">
            <h4>练习3：冒泡排序</h4>
            <p>
                编写一个汇编程序，使用冒泡排序算法对一个整数数组进行排序。
            </p>
        </div>
        <div class="solution">
            <h4> 解答 </h4>
            <pre><code>
.data
    array dd 5, 1, 4, 2, 8
    len equ ($ - array) / 4
.code
    mov ecx, len - 1 ; 外层循环次数
outer_loop:
    push ecx
    mov esi, offset array ; esi指向数组起始地址
    mov edx, 0 ; 标记是否交换过
    mov ebx, 0 ; 内层循环计数器
inner_loop:
    cmp ebx, ecx
    jge inner_loop_end
    mov eax, [esi + ebx * 4]
    mov edi, [esi + (ebx + 1) * 4]
    cmp eax, edi
    jle no_swap
    ; 交换
    mov [esi + ebx * 4], edi
    mov [esi + (ebx + 1) * 4], eax
    mov edx, 1 ; 标记有交换
no_swap:
    inc ebx
    jmp inner_loop
inner_loop_end:
    cmp edx, 0
    jz outer_loop_end ; 如果没有交换，说明已经排好序了
    pop ecx
    loop outer_loop
outer_loop_end:
            </code></pre>
        </div>

        <h2 id="resources">13. 学习资源</h2>
        <p>
            以下是一些有用的汇编语言学习资源：
        </p>
        <ul>
            <li>《汇编语言（第3版）》王爽著：一本经典的汇编语言教材，适合初学者。</li>
            <li>《Intel汇编语言程序设计（第7版）》Kip R. Irvine著：一本详细介绍x86汇编语言的教材，内容全面深入。</li>
            <li><a href="https://www.nasm.us/" target="_blank">NASM官方网站</a>：NASM汇编器的官方网站，提供最新的软件下载和文档。</li>
            <li><a href="https://docs.microsoft.com/en-us/cpp/assembler/masm-for-x86" target="_blank">MASM参考</a>：微软官方的MASM参考文档，详细介绍了MASM的语法和功能。</li>
            <li><a href="https://www.youtube.com/playlist?list=PLxCzCOWd-vLw9YFnEwCMSLq6Q5v-9TfK" target="_blank">YouTube上的汇编语言教程</a>：一个YouTube上的汇编语言教学视频系列，讲解清晰易懂。</li>
        </ul>
    </div>
</body>
</html>
