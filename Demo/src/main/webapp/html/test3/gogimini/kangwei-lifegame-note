康威生命游戏：简单规则，复杂演化

康威生命游戏 (Conway's Game of Life) 是由英国数学家约翰·霍顿·康威在 1970 年发明的“零玩家”图灵完备
 cellular automaton。
它由一个单元格网格组成，其中每个单元格都可以处于两种可能的状态之一：存活或死亡。
游戏的发展取决于一组应用于相邻单元格的简单规则。

游戏思想与哲学

生命游戏的核心在于探索以下概念：

- 涌现 (Emergence): 
  游戏展示了简单的局部规则如何能够导致复杂的全局行为和模式。
  即使游戏的规则非常简单，细胞群体的演变也可以产生令人惊讶的复杂性和不可预测性。

- 自组织 (Self-organization): 
  生命游戏模拟了自组织现象，其中结构和秩序可以从无序中自发产生。
  细胞的生死取决于其邻居的状态，但这些局部相互作用会导致全局模式的形成。

- 确定性与不确定性: 
  虽然游戏的规则是完全确定的，但由于初始条件和细胞之间的复杂相互作用，系统的长期行为可能是不可预测的。
  这反映了确定性系统可能表现出看似随机的行为。

- 生命与演化: 
  虽然生命游戏是对生物学意义上的生命的粗略抽象，但它确实能让人联想到生命、死亡和演化的过程。
  细胞的存亡取决于其“环境”，并且某些细胞组合可以“存活”很长时间，甚至“进化”成稳定的结构。

- 模拟自然本质: 
  康威生命游戏可以被视为对自然界本质的一种模拟，它揭示了复杂性和多样性是如何从简单的底层规则中产生的。
  它帮助我们理解自然界中的模式形成、生态平衡和演化过程。

设计原理和逻辑关系
- 网格: 游戏在一个二维网格上进行，网格中的每个单元格代表一个细胞。
- 状态: 每个细胞都有两种可能的状态：
  - 存活 (用 1 表示)
  - 死亡 (用 0 表示)
- 邻居: 每个细胞都有 8 个邻居：它周围的相邻细胞。
- 演化规则: 细胞的状态在每个时间步长 (称为“世代”) 都会根据以下规则更新：
  - 生存: 如果一个活细胞有 2 个或 3 个活邻居，则它在下一代中保持存活。
  - 死亡: 
    - 如果一个活细胞有少于 2 个活邻居，则它在下一代中死亡 (模拟死亡)。
    - 如果一个活细胞有超过 3 个活邻居，则它在下一代中死亡 (模拟过度拥挤)。
  - 诞生: 如果一个死细胞恰好有 3 个活邻居，则它在下一代中变成活细胞 (模拟繁殖)。

游戏架构
游戏主要由以下几个部分组成：
- 游戏网格 (GameGrid 类):
  - 负责存储和管理细胞网格的状态。
  - 提供初始化、更新和绘制网格的方法。
  - 计算细胞的邻居数量。
- 游戏 (Game 类):
  - 负责游戏的整体控制和运行。
  - 处理游戏事件 (例如，启动、暂停、重置)。
  - 管理游戏循环。
  - 绘制游戏界面，包括网格和控制按钮。
- 主程序:
  - 初始化 Pygame。
  - 创建 Game 类的实例。
  - 启动游戏循环。

代码详细注释
import pygame
import sys
import random
import time

# 初始化 Pygame
pygame.init()

# 屏幕尺寸
screen_width = 800
screen_height = 600
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption("康威生命游戏")

# 颜色定义
white = (255, 255, 255)
black = (0, 0, 0)
gray = (128, 128, 128)
green = (0, 255, 0)
blue = (0, 0, 255)
red = (255, 0, 0)

# 网格尺寸
cell_size = 10
grid_width = screen_width // cell_size
grid_height = screen_height // cell_size

# 游戏状态
grid = [[0] * grid_width for _ in range(grid_height)]  # 0: dead, 1: alive
running = False
pause = True  # 初始状态暂停
generation = 0  # 世代计数

# 字体
font = pygame.font.Font(None, 30)
large_font = pygame.font.Font(None, 40)  # 更大的字体


class GameGrid:
    """
    表示康威生命游戏的网格。
    """

    def __init__(self, width, height):
        """
        初始化网格。

        Args:
            width (int): 网格宽度。
            height (int): 网格高度。
        """
        self.width = width
        self.height = height
        self.grid = [[0] * width for _ in range(height)]  # 创建一个二维列表来存储网格状态
        self.generation = 0  # 记录当前是第几代

    def initialize(self):
        """
        随机初始化网格。
        """
        for y in range(self.height):
            for x in range(self.width):
                self.grid[y][x] = random.choice([0, 1])  # 随机选择 0 (死亡) 或 1 (存活)
        self.generation = 0

    def count_neighbors(self, x, y):
        """
        计算细胞周围的活细胞数量。

        Args:
            x (int): 细胞的 x 坐标。
            y (int): 细胞的 y 坐标。

        Returns:
            int: 活细胞的数量。
        """
        neighbors = 0
        for i in range(-1, 2):  # 遍历周围 8 个细胞
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue  # 跳过当前细胞
                nx, ny = x + i, y + j  # 计算相邻细胞的坐标
                if 0 <= nx < self.width and 0 <= ny < self.height and self.grid[ny][
                    nx] == 1:  # 检查相邻细胞是否在网格内且存活
                    neighbors += 1
        return neighbors

    def update(self):
        """
        更新网格状态。
        """
        next_grid = [[0] * self.width for _ in range(self.height)]  # 创建一个新的网格来存储下一代的状态
        for y in range(self.height):
            for x in range(self.width):
                neighbors = self.count_neighbors(x, y)  # 计算当前细胞的邻居数量
                if self.grid[y][x] == 1:  # 活细胞
                    if neighbors == 2 or neighbors == 3:
                        next_grid[y][x] = 1  # 生存
                    else:
                        next_grid[y][x] = 0  # 死亡
                else:  # 死细胞
                    if neighbors == 3:
                        next_grid[y][x] = 1  # 复活
                    else:
                        next_grid[y][x] = 0
        self.grid = next_grid  # 将下一代的状态更新为当前网格的状态
        self.generation += 1  # 世代数加 1

    def draw(self, surface, cell_size):
        """
        绘制网格。

        Args:
            surface (pygame.Surface): 要绘制的 Surface。
            cell_size (int): 细胞的大小。
        """
        surface.fill(black)  # 用黑色填充整个 Surface
        for y in range(self.height):
            for x in range(self.width):
                if self.grid[y][x] == 1:
                    pygame.draw.rect(surface, green,
                                     (x * cell_size, y * cell_size, cell_size,
                                      cell_size))  # 绘制绿色矩形表示活细胞
                else:
                    pygame.draw.rect(surface, gray,
                                     (x * cell_size, y * cell_size, cell_size,
                                      cell_size),
                                     1)  # 绘制灰色边框表示死细胞

    def get_generation(self):
        """
        获取当前的世代数。

        Returns:
            int: 当前世代数。
        """
        return self.generation


class Game:
    """
    表示康威生命游戏的整体。
    包含网格、界面和游戏循环。
    """

    def __init__(self, screen, grid_width, grid_height, cell_size):
        """
        初始化游戏。

        Args:
            screen (pygame.Surface): 游戏窗口。
            grid_width (int): 网格宽度。
            grid_height (int): 网格高度。
            cell_size (int): 细胞大小
        """
        self.screen = screen  # 游戏窗口
        self.grid = GameGrid(grid_width,
                             grid_height)  # 创建 GameGrid 类的实例来表示游戏网格
        self.cell_size = cell_size  # 细胞大小
        self.running = False  # 游戏是否正在运行
        self.pause = True  # 游戏是否暂停
        self.start_pause_button_rect = None  # 开始/暂停 按钮的 Rect
        self.reset_button_rect = None  # 重置 按钮的 Rect
        self.generation_display_rect = None  # 世代数显示区域的 Rect

    def initialize(self):
        """
        初始化游戏。
        """
        self.grid.initialize()  # 初始化游戏网格
        self.running = False  # 游戏开始时暂停
        self.pause = True
        self.generation = 0

    def handle_events(self):
        """
        处理游戏事件。
        """
        for event in pygame.event.get():  # 获取所有发生的事件
            if event.type == pygame.QUIT:  # 如果用户点击了关闭按钮
                pygame.quit()  # 退出 Pygame
                sys.exit()  # 退出程序
            elif event.type == pygame.KEYDOWN:  # 如果用户按下了键盘上的某个键
                if event.key == pygame.K_SPACE:  # 如果用户按下了空格键
                    self.running = not self.running  # 切换运行状态
                    self.pause = not self.pause
                elif event.key == pygame.K_r:  # 如果用户按下了 'r' 键
                    self.initialize()  # 重置游戏
            elif event.type == pygame.MOUSEBUTTONDOWN:  # 如果用户点击了鼠标按钮
                self.handle_mouse_click(event)  # 处理鼠标点击事件

    def handle_mouse_click(self, event):
        """
        处理鼠标点击事件。
        """
        # 检查是否点击了网格
        grid_x = event.pos[0] // self.cell_size  # 将鼠标坐标转换为网格坐标
        grid_y = event.pos[1] // self.cell_size
        if 0 <= grid_x < self.grid.width and 0 <= grid_y < self.grid.height:
            self.grid.grid[grid_y][
                grid_x] = 1 - self.grid.grid[grid_y][
                grid_x]  # 切换细胞状态 (点击活细胞变成死细胞，点击死细胞变成活细胞)
        # 检查是否点击了按钮
        if self.start_pause_button_rect and self.start_pause_button_rect.collidepoint(
                event.pos):  # 如果点击了 "Start/Pause" 按钮
            if self.pause:  # 如果当前是暂停状态，点击 Start
                self.pause = False
                self.running = True
        elif self.pause_button_rect and self.pause_button_rect.collidepoint(event.pos):
            if not self.pause:  # 如果当前是运行状态，点击 Pause
                self.pause = True
                self.running = False
        elif self.reset_button_rect and self.reset_button_rect.collidepoint(
                event.pos):  # 如果点击了 "Reset" 按钮
            self.initialize()  # 重置游戏

    def draw(self):
        """
        绘制游戏界面。
        """
        self.grid.draw(self.screen,
                       self.cell_size)  # 绘制游戏网格
        self.display_generation()  # 显示当前世代数
        self.start_pause_button_rect, self.pause_button_rect, self.reset_button_rect = self.display_control_buttons()  # 获取按钮rect

    def display_generation(self):
        """
        显示世代数。
        """
        text = large_font.render(
            f"Generation: {self.grid.get_generation()}",
            True,
            white)  # 使用 large_font 渲染世代数
        self.generation_display_rect = text.get_rect(
            topleft=(10, 10))  # 获取文本的 Rect
        self.screen.blit(text,
                         self.generation_display_rect)  # 将文本绘制到屏幕上

    def display_control_buttons(self):
        """
        显示控制按钮.
        """
        start_pause_text = large_font.render("Start", True,
                                             white)  # 简化文本
        pause_text = large_font.render("Pause", True, white)
        reset_text = large_font.render("Reset", True, white)  # 保持文本一致
        # 定义按钮的 Rect
        start_pause_button_rect = start_pause_text.get_rect(
            topleft=(10, screen_height - 50))  # 调整按钮位置
        pause_button_rect = pause_text.get_rect(
            topleft=(10 + start_pause_button_rect.width + 10,
                     screen_height - 50))
        reset_button_rect = reset_text.get_rect(
            topleft=(10 + start_pause_button_rect.width + 10 +
                     pause_button_rect.width + 10,
                     screen_height - 50))  # 调整按钮位置，避免重叠

        # 画按钮
        pygame.draw.rect(self.screen, green,
                         start_pause_button_rect)  # 绘制 "Start" 按钮
        pygame.draw.rect(self.screen, blue,
                         pause_button_rect)  # 绘制 "Pause" 按钮
        pygame.draw.rect(self.screen, red,
                         reset_button_rect)  # 绘制 "Reset" 按钮

        # 画按钮文字
        screen.blit(start_pause_text, start_pause_button_rect)
        screen.blit(pause_text, pause_button_rect)
        screen.blit(reset_text, reset_button_rect)  # 绘制 "Reset" 按钮文字

        return start_pause_button_rect, pause_button_rect, reset_button_rect

    def update(self):
        """
        更新游戏状态。
        """
        if not self.pause:  # 如果游戏没有暂停
            self.grid.update()  # 更新网格状态

    def run(self):
        """
        运行游戏主循环。
        """
        self.initialize()  # 初始化游戏
        while True:  # 游戏主循环
            self.handle_events()  # 处理游戏事件
            self.draw()  # 绘制游戏界面
            self.update()  # 更新游戏状态
            pygame.display.flip()  # 更新屏幕显示
            pygame.time.delay(
                100)  # 控制游戏速度，降低 CPU 占用 (100 毫秒延迟)


if __name__ == '__main__':
    game = Game(screen, grid_width, grid_height,
                cell_size)  # 创建 Game 类的实例
    game.run()  # 运行游戏
