<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>逻辑关系连接游戏（改进版）</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: Arial, 'Microsoft YaHei', sans-serif; }
        canvas { border: 1px solid black; }
        .controls, .setup { margin: 10px; }
        button, input, select { margin: 5px; padding: 8px; font-size: 14px; }
        #status { margin: 10px; font-size: 16px; }
        #answers { display: flex; justify-content: space-around; width: 600px; }
        .answer-btn { cursor: pointer; background-color: #f0f0f0; border: 1px solid #ccc; padding: 10px; }
        .answer-btn:hover { background-color: #ddd; }
        p { margin: 10px; max-width: 600px; }
    </style>
</head>
<body>
    <h1>逻辑关系连接游戏</h1>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div class="setup">
        <h3>设置关键词和关系</h3>
        <div>
            <label>手动输入关键词: <input type="text" id="keywordInput" placeholder="例如：太阳 光 热"></label>
            <button onclick="addKeywords()">添加</button>
        </div>
        <div>
            <label>上传关键词文件: <input type="file" id="fileInput" accept=".txt"></label>
        </div>
        <div>
            <label>定义关系: </label>
            <select id="keyword1"></select>
            <select id="keyword2"></select>
            <select id="relation">
                <option value="因果">因果</option>
                <option value="包含">包含</option>
                <option value="对立">对立</option>
                <option value="相似">相似</option>
            </select>
            <button onclick="addRelation()">添加关系</button>
        </div>
    </div>
    <div class="controls">
        <button onclick="startGame()">开始</button>
        <button onclick="pauseGame()">暂停</button>
        <button onclick="resetGame()">重置</button>
        <button onclick="nextBatch()">下一批次</button>
    </div>
    <div id="answers"></div>
    <div id="status">分数: 0 | 当前批次: 1 | 剩余关键词对: 0</div>
    <p>输入关键词（最多5个，用空格分隔，如“太阳 光 热”）或上传文本文件（每行以空格分隔关键词，如“太阳 光 热”）。定义关键词对的逻辑关系。点击“开始”，关键词从顶部循环落下，从底部选择正确关系，正确时连接并显示关系。目标：持续连接关键词对，获得高分！</p>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let keywordBatches = [[]]; // 存储多批次关键词
        let currentBatch = 0;
        let relations = {};
        let fallingPairs = [];
        let connectedPairs = [];
        let score = 0;
        let isRunning = false;
        let animationId;

        // 初始化游戏
        function initGame() {
            keywordBatches = [[]];
            currentBatch = 0;
            relations = {};
            fallingPairs = [];
            connectedPairs = [];
            score = 0;
            updateStatus();
            updateKeywordDropdowns();
            updateAnswers();
        }

        // 添加手动输入的关键词
        function addKeywords() {
            const input = document.getElementById('keywordInput').value.trim();
            if (input) {
                const newKeywords = input.split(/\s+/).map(k => k.trim()).filter(k => k);
                if (keywordBatches[currentBatch].length + newKeywords.length <= 5) {
                    keywordBatches[currentBatch].push(...newKeywords);
                    document.getElementById('keywordInput').value = '';
                    updateKeywordDropdowns();
                } else {
                    alert('每批最多允许5个关键词！');
                }
            }
        }

        // 处理文件上传
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const content = event.target.result;
                    keywordBatches = content.split('\n').map(line => 
                        line.trim().split(/\s+/).filter(k => k)
                    ).filter(batch => batch.length > 0);
                    currentBatch = 0;
                    updateKeywordDropdowns();
                    updateStatus();
                };
                reader.readAsText(file);
            }
        });

        // 更新关键词下拉菜单
        function updateKeywordDropdowns() {
            const kw1 = document.getElementById('keyword1');
            const kw2 = document.getElementById('keyword2');
            kw1.innerHTML = '';
            kw2.innerHTML = '';
            const keywords = keywordBatches[currentBatch] || [];
            keywords.forEach(k => {
                const option1 = document.createElement('option');
                option1.value = k;
                option1.text = k;
                kw1.appendChild(option1);
                const option2 = document.createElement('option');
                option2.value = k;
                option2.text = k;
                kw2.appendChild(option2);
            });
        }

        // 添加关系
        function addRelation() {
            const kw1 = document.getElementById('keyword1').value;
            const kw2 = document.getElementById('keyword2').value;
            const relation = document.getElementById('relation').value;
            if (kw1 && kw2 && kw1 !== kw2) {
                relations[`${kw1}:${kw2}`] = relation;
                relations[`${kw2}:${kw1}`] = relation; // 对称关系
            }
        }

        // 更新答案按钮
        function updateAnswers() {
            const answersDiv = document.getElementById('answers');
            answersDiv.innerHTML = '';
            ['因果', '包含', '对立', '相似'].forEach(rel => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = rel;
                btn.onclick = () => selectRelation(rel);
                answersDiv.appendChild(btn);
            });
        }

        // 选择关系
        function selectRelation(relation) {
            if (fallingPairs.length > 0) {
                const pair = fallingPairs[0];
                const correctRelation = relations[`${pair.kw1}:${pair.kw2}`] || relations[`${pair.kw2}:${pair.kw1}`];
                if (correctRelation === relation) {
                    pair.connected = true;
                    pair.relation = relation;
                    connectedPairs.push(pair);
                    fallingPairs.shift();
                    score += 10;
                } else {
                    score = Math.max(0, score - 5);
                }
                updateStatus();
            }
        }

        // 绘制游戏
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 绘制网格
            ctx.strokeStyle = '#ccc';
            for (let i = 0; i <= canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            // 绘制下落关键词
            fallingPairs.forEach(pair => {
                if (!pair.connected) {
                    ctx.fillStyle = pair.kw1Color;
                    ctx.fillRect(pair.kw1X, pair.kw1Y, 80, 40);
                    ctx.fillStyle = 'black';
                    ctx.font = '16px Microsoft YaHei';
                    ctx.fillText(pair.kw1, pair.kw1X + 5, pair.kw1Y + 28);
                    ctx.fillStyle = pair.kw2Color;
                    ctx.fillRect(pair.kw2X, pair.kw2Y, 80, 40);
                    ctx.fillStyle = 'black';
                    ctx.fillText(pair.kw2, pair.kw2X + 5, pair.kw2Y + 28);
                }
            });
            // 绘制已连接的关键词
            connectedPairs.forEach(pair => {
                ctx.beginPath();
                ctx.moveTo(pair.kw1X + 40, pair.kw1Y + 20);
                ctx.lineTo(pair.kw2X + 40, pair.kw2Y + 20);
                ctx.strokeStyle = 'green';
                ctx.stroke();
                ctx.fillStyle = pair.kw1Color;
                ctx.fillRect(pair.kw1X, pair.kw1Y, 80, 40);
                ctx.fillStyle = pair.kw2Color;
                ctx.fillRect(pair.kw2X, pair.kw2Y, 80, 40);
                ctx.fillStyle = 'black';
                ctx.font = '16px Microsoft YaHei';
                ctx.fillText(pair.kw1, pair.kw1X + 5, pair.kw1Y + 28);
                ctx.fillText(pair.kw2, pair.kw2X + 5, pair.kw2Y + 28);
                ctx.fillText(pair.relation, (pair.kw1X + pair.kw2X) / 2 + 40, (pair.kw1Y + pair.kw2Y) / 2 + 20);
            });
        }

        // 更新游戏状态
        function updateGame() {
            const keywords = keywordBatches[currentBatch] || [];
            if (keywords.length < 2) {
                alert('当前批次关键词不足，请添加关键词或上传文件！');
                pauseGame();
                return;
            }
            if (fallingPairs.length === 0) {
                const availablePairs = Object.keys(relations).filter(k => 
                    !fallingPairs.some(p => `${p.kw1}:${p.kw2}` === k || `${p.kw2}:${p.kw1}` === k) &&
                    keywords.includes(k.split(':')[0]) && keywords.includes(k.split(':')[1])
                );
                if (availablePairs.length === 0) {
                    currentBatch = (currentBatch + 1) % keywordBatches.length;
                    connectedPairs = [];
                    return;
                }
                const pairKey = availablePairs[Math.floor(Math.random() * availablePairs.length)];
                const [kw1, kw2] = pairKey.split(':');
                const x1 = Math.random() * (canvas.width - 160);
                const x2 = x1 + 100;
                fallingPairs.push({
                    kw1,
                    kw2,
                    kw1X: x1,
                    kw1Y: 0,
                    kw2X: x2,
                    kw2Y: 0,
                    kw1Speed: Math.random() * 1 + 1,
                    kw2Speed: Math.random() * 1 + 1,
                    kw1Color: `hsl(${Math.random() * 360}, 70%, 70%)`,
                    kw2Color: `hsl(${Math.random() * 360}, 70%, 70%)`,
                    connected: false
                });
            }
            fallingPairs.forEach(pair => {
                if (!pair.connected) {
                    pair.kw1Y += pair.kw1Speed;
                    pair.kw2Y += pair.kw2Speed;
                    if (pair.kw1Y > canvas.height - 40 || pair.kw2Y > canvas.height - 40) {
                        fallingPairs.shift();
                        score = Math.max(0, score - 5);
                        updateStatus();
                    }
                }
            });
            drawGame();
        }

        // 更新状态
        function updateStatus() {
            document.getElementById('status').textContent = `分数: ${score} | 当前批次: ${currentBatch + 1} | 剩余关键词对: ${Object.keys(relations).length / 2 - connectedPairs.length}`;
        }

        // 开始游戏
        function startGame() {
            if (!isRunning && keywordBatches[currentBatch].length >= 2 && Object.keys(relations).length > 0) {
                isRunning = true;
                animate();
            } else {
                alert('请添加至少2个关键词和1个关系！');
            }
        }

        // 动画循环
        function animate() {
            if (isRunning) {
                updateGame();
                animationId = requestAnimationFrame(animate);
            }
        }

        // 暂停游戏
        function pauseGame() {
            isRunning = false;
            cancelAnimationFrame(animationId);
        }

        // 重置游戏
        function resetGame() {
            pauseGame();
            initGame();
            drawGame();
        }

        // 下一批次
        function nextBatch() {
            pauseGame();
            connectedPairs = [];
            currentBatch = (currentBatch + 1) % keywordBatches.length;
            updateKeywordDropdowns();
            updateStatus();
            drawGame();
        }

        // 初始化
        initGame();
        drawGame();
    </script>
</body>
</html>