<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>推箱子游戏</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #333;
            background-color: #fff;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        p {
            font-size: 18px;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>推箱子游戏</h1>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div class="controls">
        <p>使用方向键（↑↓←→）移动玩家，推箱子到红色目标点</p>
        <button onclick="resetGame()">重置游戏</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 游戏设置
        const tileSize = 40; // 每个格子大小
        const gridSize = 10; // 10x10 网格
        const level = [
            ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '@', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '$', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '$', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '*', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#']
        ];
        // 符号说明：
        // # : 墙壁
        // . : 空地
        // @ : 玩家
        // $ : 箱子
        // * : 目标点

        let player = { x: 2, y: 2 }; // 玩家初始位置
        let boxes = [{ x: 4, y: 3 }, { x: 5, y: 5 }]; // 箱子初始位置
        let targets = [{ x: 8, y: 7 }]; // 目标点位置
        let gameState = JSON.parse(JSON.stringify(level)); // 深拷贝初始关卡

        // 绘制游戏
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const tile = gameState[y][x];
                    ctx.fillStyle = tile === '#' ? '#333' : tile === '*' ? '#ff0000' : '#fff';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);

                    if (tile === '@') {
                        ctx.fillStyle = '#00f';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === '$') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x * tileSize + 5, y * tileSize + 5, tileSize - 10, tileSize - 10);
                    }
                }
            }
        }

        // 检查是否胜利
        function checkWin() {
            return targets.every(target => 
                boxes.some(box => box.x === target.x && box.y === target.y)
            );
        }

        // 处理玩家移动
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            // 检查新位置是否合法
            if (gameState[newY][newX] === '#' || newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
                return;
            }

            // 检查是否推箱子
            let boxIndex = boxes.findIndex(box => box.x === newX && box.y === newY);
            if (boxIndex !== -1) {
                const boxNewX = newX + dx;
                const boxNewY = newY + dy;
                if (gameState[boxNewY][boxNewX] === '#' || 
                    boxes.some((box, i) => i !== boxIndex && box.x === boxNewX && box.y === boxNewY) ||
                    boxNewX < 0 || boxNewX >= gridSize || boxNewY < 0 || boxNewY >= gridSize) {
                    return;
                }
                // 更新箱子位置
                boxes[boxIndex] = { x: boxNewX, y: boxNewY };
                gameState[boxNewY][boxNewX] = '$';
            }

            // 更新玩家位置
            gameState[player.y][player.x] = level[player.y][player.x] === '*' ? '*' : '.';
            player = { x: newX, y: newY };
            gameState[newY][newX] = '@';

            drawGame();
            if (checkWin()) {
                alert('恭喜！你赢了！');
            }
        }

        // 重置游戏
        function resetGame() {
            gameState = JSON.parse(JSON.stringify(level));
            player = { x: 2, y: 2 };
            boxes = [{ x: 4, y: 3 }, { x: 5, y: 5 }];
            drawGame();
        }

        // 键盘事件
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
            }
        });

        // 初始绘制
        drawGame();
    </script>
</body>
我将创建一个基于HTML5 Canvas的简单推箱子（Sokoban）网页游戏，包含基本的游戏逻辑、玩家移动、箱子推动和胜利检测功能。游戏将使用键盘控制，玩家推动箱子到目标位置。以下是完整的代码和详细的编写思路与分析文档。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>推箱子游戏</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #333;
            background-color: #fff;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        p {
            font-size: 18px;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>推箱子游戏</h1>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div class="controls">
        <p>使用方向键（↑↓←→）移动玩家，推箱子到红色目标点</p>
        <button onclick="resetGame()">重置游戏</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 游戏设置
        const tileSize = 40; // 每个格子大小
        const gridSize = 10; // 10x10 网格
        const level = [
            ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '@', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '$', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '$', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '*', '#'],
            ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
            ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#']
        ];
        // 符号说明：
        // # : 墙壁
        // . : 空地
        // @ : 玩家
        // $ : 箱子
        // * : 目标点

        let player = { x: 2, y: 2 }; // 玩家初始位置
        let boxes = [{ x: 4, y: 3 }, { x: 5, y: 5 }]; // 箱子初始位置
        let targets = [{ x: 8, y: 7 }]; // 目标点位置
        let gameState = JSON.parse(JSON.stringify(level)); // 深拷贝初始关卡

        // 绘制游戏
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const tile = gameState[y][x];
                    ctx.fillStyle = tile === '#' ? '#333' : tile === '*' ? '#ff0000' : '#fff';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);

                    if (tile === '@') {
                        ctx.fillStyle = '#00f';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === '$') {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x * tileSize + 5, y * tileSize + 5, tileSize - 10, tileSize - 10);
                    }
                }
            }
        }

        // 检查是否胜利
        function checkWin() {
            return targets.every(target => 
                boxes.some(box => box.x === target.x && box.y === target.y)
            );
        }

        // 处理玩家移动
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            // 检查新位置是否合法
            if (gameState[newY][newX] === '#' || newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
                return;
            }

            // 检查是否推箱子
            let boxIndex = boxes.findIndex(box => box.x === newX && box.y === newY);
            if (boxIndex !== -1) {
                const boxNewX = newX + dx;
                const boxNewY = newY + dy;
                if (gameState[boxNewY][boxNewX] === '#' || 
                    boxes.some((box, i) => i !== boxIndex && box.x === boxNewX && box.y === boxNewY) ||
                    boxNewX < 0 || boxNewX >= gridSize || boxNewY < 0 || boxNewY >= gridSize) {
                    return;
                }
                // 更新箱子位置
                boxes[boxIndex] = { x: boxNewX, y: boxNewY };
                gameState[boxNewY][boxNewX] = '$';
            }

            // 更新玩家位置
            gameState[player.y][player.x] = level[player.y][player.x] === '*' ? '*' : '.';
            player = { x: newX, y: newY };
            gameState[newY][newX] = '@';

            drawGame();
            if (checkWin()) {
                alert('恭喜！你赢了！');
            }
        }

        // 重置游戏
        function resetGame() {
            gameState = JSON.parse(JSON.stringify(level));
            player = { x: 2, y: 2 };
            boxes = [{ x: 4, y: 3 }, { x: 5, y: 5 }];
            drawGame();
        }

        // 键盘事件
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
            }
        });

        // 初始绘制
        drawGame();
    </script>
</body>
</html>
<!--

### 如何玩
1. 打开网页，使用方向键（↑↓←→）控制蓝色圆形玩家移动。
2. 将棕色箱子推到红色目标点上。
3. 玩家只能推动箱子，不能拉动；箱子不能推到墙壁或另一个箱子上。
4. 当所有箱子都到达目标点时，弹出胜利提示。
5. 点击“重置游戏”按钮可重新开始。

### 编写程序的思路与分析

#### 1. 设计目标
- **核心功能**：实现经典推箱子游戏，包含玩家移动、箱子推动、墙壁阻挡和胜利检测。
- **技术选择**：使用HTML5 Canvas绘制游戏，JavaScript处理逻辑，CSS提供简单样式。
- **用户体验**：键盘控制，简单直观的界面，包含重置功能和胜利提示。
- **简化设计**：单关卡，10x10网格，1个目标点，2个箱子，保持代码简洁。

#### 2. 程序结构
- **HTML结构**：
  - 一个 `<canvas>` 元素用于绘制游戏。
  - 一个按钮用于重置游戏，提示文字说明操作。
- **CSS样式**：
  - 居中布局，简洁的按钮和画布样式。
  - 背景色和边框增强视觉效果。
- **JavaScript逻辑**：
  - **数据结构**：使用二维数组表示关卡，对象数组存储玩家、箱子和目标点位置。
  - **绘制**：使用 Canvas 绘制网格、墙壁、玩家、箱子和目标点。
  - **输入处理**：监听键盘事件，处理玩家移动和箱子推动。
  - **游戏逻辑**：检查移动合法性、更新状态、检测胜利条件。
  - **重置功能**：恢复初始关卡状态。

#### 3. 实现步骤
1. **定义关卡**：
   - 使用二维数组表示10x10网格，包含墙壁（`#`）、空地（`.`）、玩家（`@`）、箱子（`$`）和目标点（`*`）。
   - 存储玩家和箱子的动态位置，目标点位置固定。
2. **绘制游戏**：
   - 使用 `ctx.fillRect` 绘制网格，颜色区分墙壁（灰色）、空地（白色）、目标点（红色）。
   - 玩家用蓝色圆形（`ctx.arc`），箱子用棕色矩形。
   - 每次移动后重绘整个画布。
3. **处理移动**：
   - 监听键盘方向键，计算玩家新位置。
   - 检查新位置是否为墙壁或超出边界。
   - 如果新位置有箱子，检查箱子新位置是否合法（无墙壁、无其他箱子）。
   - 更新玩家和箱子位置，保持目标点标记。
4. **胜利检测**：
   - 检查所有目标点是否被箱子覆盖。
   - 使用 `every` 和 `some` 方法验证箱子与目标点坐标匹配。
5. **重置功能**：
   - 深拷贝初始关卡，恢复玩家和箱子位置。
   - 调用绘制函数刷新画布。

#### 4. 关键代码分析
- **关卡数据**：
  ```javascript
  const level = [
      ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
      // ...
  ];
  ```
  - 使用数组定义静态关卡，便于修改或扩展多关卡。
- **绘制函数**：
  ```javascript
  function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
              // 绘制网格和元素
          }
      }
  }
  ```
  - 每次重绘整个画布，确保状态一致。
- **移动逻辑**：
  ```javascript
  function movePlayer(dx, dy) {
      const newX = player.x + dx;
      const newY = player.y + dy;
      if (gameState[newY][newX] === '#' || ...) return;
      let boxIndex = boxes.findIndex(...);
      if (boxIndex !== -1) {
          // 检查并更新箱子位置
      }
      // 更新玩家位置
  }
  ```
  - 分步检查合法性，处理箱子推动逻辑。
- **胜利检测**：
  ```javascript
  function checkWin() {
      return targets.every(target => 
          boxes.some(box => box.x === target.x && box.y === target.y)
      );
  }
  ```
  - 简洁高效的逻辑，检查目标点是否全被覆盖。

#### 5. 优化与扩展
- **性能优化**：
  - 当前游戏规模小，逐帧重绘可接受。大型关卡可使用离屏画布缓存静态元素。
  - 避免频繁深拷贝，使用增量更新状态。
- **扩展功能**：
  - **多关卡**：定义多个 `level` 数组，添加关卡选择界面。
  - **撤销功能**：记录移动历史，允许玩家回退。
  - **动画效果**：在移动时添加平滑过渡（需调整绘制逻辑）。
  - **关卡编辑器**：允许用户自定义关卡，保存到 `localStorage`。
- **用户体验**：
  - 添加音效（成功推动、胜利时）。
  - 显示移动步数或计时。
  - 支持触摸屏设备（添加虚拟方向键）。

#### 6. 潜在问题与解决方案
- **跨浏览器兼容性**：
  - 测试主要浏览器（Chrome、Firefox、Edge），确保键盘事件和Canvas渲染一致。
  - 移动端可能需额外处理触摸事件。
- **关卡设计**：
  - 当前关卡简单，复杂关卡需验证可解性。
  - 避免死锁（如箱子被推到角落）。
- **性能**：
  - 大型关卡可能导致绘制缓慢，可优化为只重绘变化区域。

#### 7. 注释说明
- 代码中包含关键注释，说明符号含义（如 `#` 表示墙壁）和函数作用。
- 结构化注释帮助开发者理解关卡数据和逻辑流程。
- 可扩展性注释（如箱子/目标点数组）便于未来修改。

### 总结
这个推箱子游戏实现了核心功能，代码结构清晰，易于扩展。通过Canvas绘制和键盘事件处理，提供了流畅的游戏体验。设计思路遵循模块化原则，逻辑分为数据管理、渲染和交互处理。未来可通过添加关卡、动画或撤销功能进一步丰富游戏。

如果需要特定功能（如多关卡、计步器）或进一步调试，请告诉我！ -->
</html>